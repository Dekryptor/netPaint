<!-- Room Component - Sebastian Streich 

Die Room Component klinkt sich in das Socket des Parents ein und 
übernimmt die Verwaltung des GruppenRaumes. 

-->


<script>
    (function() {
    	
    	
    //Den Protoypen Erstellen und Erweitern
    var Room = Object.create(HTMLElement.prototype);
    
    Room.notifyMessage = function(envelope) {
        //Ein Event schicken, an alle Elemente die sich an den Typ der Message gebunden haben.
        var event = new CustomEvent(envelope.topic, { 'detail': envelope.data });
        this.dispatchEvent(event);
    };
    
    
    Room.sendKeepAlive = function() {
        var name = this.getAttribute("username");
        this.Network.sendMessage("keepAlive",name);
    };
    Room.cleanKeepAliveArray = function() {
        //Clients die innerhalb von 10s kein keepAlive geschickt haben, löschen
        var persons = this.persons;
        var now = new Date().getTime();
        for (var i in persons){
            if(persons[i] <= now-10000 ){
                delete persons[i]; //Das Element entfernen
            }
        }
    };
    
    Room.getPersonCount = function() {
         return Object.keys(this.persons).length;  
    };
    
    Room.init =function() {
        var self = this;
        self.persons = {};
        //Webworker Erstellen 
        var worker = new Worker("/app/js/lib/RoomWorker.js");
        worker.addEventListener("message",function(msg) {
            if(msg.data.data == self.getAttribute('room')){
                // Enschlüsselte "join"-Anfrage für den Aktuellen Raum bekommen.
                if(self.getPersonCount() <3){
                    //Join Anfrage Bestätigen
                    self.Network.sendDefaultEncryptedMessage(self.getAttribute('room'),self.Network.cryptoManager.getInitVektor()); 
                }
                else{
                    self.Network.sendDefaultEncryptedMessage(self.getAttribute('room'),undefined);
                }
            }
        });
        
        //An die Broadcastnachrrichten des Parent-Elements binden.
        this.Network.addEventListener("broadcast",function(msg) {
            //Wenn eine nicht entschlüsselbare Nachrricht gefunden wird, auf "join"" Nachrrichten untersuchen.
            worker.postMessage((msg.detail));
        });
        
        this.Network.addEventListener("keepAlive",function(msg) {
            //Der KeepAlive wird Periodisch gesendet um anderen Mitgliedern im Raum zu signalisieren das man noch da ist.  
            //TODO: Handeln
            self.persons[msg.detail] = new Date().getTime();
        });
        
        window.setInterval(this.sendKeepAlive.bind(this),5000); //Alle 5s ein Keepalive Schicken
        window.setInterval(this.cleanKeepAliveArray.bind(this),8000); //Alle 8s das Keepalive array aufräumen
        
    };
 
    	
    Room.createdCallback = function() 
    {
        if(this.Network == undefined && this.parentNode != undefined){
            this.Network = this.parentNode;
            this.init();
        }
    };
    Room.attachedCallback = function() {
        if(this.Network == undefined && this.parentNode != undefined){
            this.Network = this.parentNode;
            this.init();
        }
    };
        
   
     document.registerElement('x-room', {prototype: Room});
    }());
</script>
<!-- Menu Component -Sebastian Streich

Erstellt eine Appbar an der Linken Seite die Buttons als Inhalt aufnimmt. 
Besitzt einen Button zum Verstecken des Menus wenn nicht gebraucht
-->

<template id="menu-template">
  	<div id="viewport">
          <div id='sidebar' class="">
            <div id='content-holder'>                
                    <content>
          
                    </content>
                    <hr></hr>  
            
              <button id='toggle-view'type="button" class='entypo-eye'></button> 
            </div>
          </div>
  	</div>
</template>


<script>
(function() {
  
  	var menu = Object.create(HTMLElement.prototype);
  	menu.createdCallback = function() {
          var tree      = this.createShadowRoot();
          var template  = document.querySelector('link[rel="import"]').import.querySelector('#menu-template');
          var clone = document.importNode(template.content, true);
          tree.appendChild(clone);
          
          //
          var visibilityswitch = tree.querySelector('#toggle-view');
          visibilityswitch.addEventListener
          ("click",function(e) {
             var sidebar = tree.querySelector('#sidebar');
             if(sidebar.getAttribute("class") != "hidden"){ sidebar.setAttribute ('class','hidden');}
             else {sidebar.setAttribute ('class','');}
          });
          
    };
      	


    document.registerElement('x-Menu', {prototype: menu});
}());
</script>


<!-- Network Component - Sebastian Streich 
Abstraktion des SocketManagers in eine HTML Component 



-->
<script>
    // Prototypen des EncryptionHandlers Definieren
    (function() {
    	var EncryptionHandler = (function () {
        function EncryptionHandler(keydata, initVektor) {
            var self = this;
            if (initVektor == undefined || initVektor.length == 0) {
                //Einen initierungsvektor erstellen, wenn keiner übergeben wurde.
                this.iv = window.crypto.getRandomValues(new Uint8Array(16));
            }
            else {
                this.iv = initVektor;
            }
            //Aus dem Raum-Namen einen 256bit Hash erstellen.
            this.sha256(keydata).then(function (digest) {
                //Aus dem Hash und den Vektor einen Cryptokey für AEC-CBC erstellen und Speichern.
                crypto.subtle.importKey("raw", digest, "AES-CBC", true, ["encrypt", "decrypt"]).then(function (keyObj) {
                    self.key = keyObj;
                });
            });
        }
        EncryptionHandler.prototype.sha256 = function (str) {
            // String in einen Arraybuffer umwandeln
            var buffer = new TextEncoder("utf-8").encode(str);
            return window.crypto.subtle.digest("SHA-256", buffer).then(function (hash) {
                return hash;
            });
        };
        EncryptionHandler.prototype.encryptString = function (data) {
            //Einen String mit dem AES-Key Verschlüsseln. 
            //Gibt einen Promise zurück - Welcher einen JSONifed String zurück gibt
            var self = this;
            var buffer = new TextEncoder('utf-8').encode(data);
            return new Promise(function (resolve, reject) {
                self.encryptBuffer(buffer).then(function (ergebnis) {
                    var bufferArray = new Uint8Array(ergebnis);
                    resolve(JSON.stringify(bufferArray));
                }).catch(function (reason) {
                    reject(reason);
                });
            });
        };
        EncryptionHandler.prototype.encryptBuffer = function (data) {
            //Einen Buffer mit dem AES-Key Verschlüsseln. 
            //Gibt einen Promise zurück mit einem Buffer als Argument
            var self = this;
            if (this.key == null) {
                throw new Error("Cryptokey ist nicht initialisiert.");
            }
            return new Promise(function (resolve, reject) {
                crypto.subtle.encrypt({ name: "AES-CBC", iv: self.iv }, self.key, data).then(function (encryptedBuffer) {
                    resolve(encryptedBuffer);
                }, function (params) {
                    reject(params);
                });
            });
        };
        EncryptionHandler.prototype.decryptJSON = function (data) {
            //Einen JSON-String mit dem AES-Key Entschlüsseln. 
            //Gibt einen Promise zurück - Welcher den UR - String zurück gibt
            var self = this;
            return new Promise(function (resolve, reject) {
                //Aus der JSON wieder einen Buffer erzeugen - Da der Server keine Binäre Übertragung unterstüzt.
                var obj = JSON.parse(data);
                var arr = [];
                for (var i in obj) {
                    arr[i] = obj[i];
                }
                var buffer = new Uint8Array(arr).buffer;
                //Buffer entschlüsseln
                self.decryptBuffer(buffer).then(function (decryptedBuffer) {
                    //Aus Buffer wieder einen String machen
                    resolve(new TextDecoder('utf-8').decode(decryptedBuffer));
                }).catch(function (reason) {
                    reject(reason);
                });
            });
        };
        EncryptionHandler.prototype.decryptBuffer = function (data) {
            //Einen Buffer entschlüsseln. 
            //Rückgabewert ist ein Promise mit Buffer als Argument.
            var self = this;
            return new Promise(function (resolve, reject) {
                crypto.subtle.decrypt({ name: "AES-CBC", iv: self.iv }, self.key, data).then(function (decryptedBuffer) {
                    resolve(decryptedBuffer);
                }).catch(function (reason) {
                    reject(reason);
                });
            });
        };
        EncryptionHandler.prototype.getInitVektor = function () {
            //Den IV Lesbar machen
            return this.iv;
        };
        return EncryptionHandler;
    })();
    	
    //Den Protoypen Erstellen und Erweitern
    var Network = Object.create(HTMLElement.prototype);
    
    Network.notifyMessage = function(envelope) {
        //Ein Event schicken, an alle Elemente die sich an den Typ der Message gebunden haben.
        var event = new CustomEvent(envelope.topic, { 'detail': envelope.data });
        this.dispatchEvent(event);
    };
    
    
    Network.init = function(url) { 
       var self    = this;
       //Standard CryptoObjekt Erstellen
       var defaultvek      = new Uint8Array([38, 86, 215, 184, 230, 210, 185, 187, 139, 141, 157, 192, 67, 41, 251, 58]);
       this.cryptoDefault  = new EncryptionHandler("none",defaultvek);
        
       //Einen neuen WebSocket Öffnen
       this.ws = new WebSocket(url);
       this.ws.onopen = function(params) {
    	   console.log("Verbindung Geöffnet.");
    	   //Generellen CryptoManager laden.
    	   self.cryptoManager = self.cryptoDefault;
           self.setAttribute("connected","true");
    	};
        
       //Eventlistner für das Empfangen erstellen
       this.ws.addEventListener('message', function(message) {
    			//Nachricht enschlüsseln
    			self.cryptoManager.decryptJSON(message.data)
    		      .then(function(decryptedMessage) {
        				var envelope = JSON.parse(decryptedMessage);
        				self.notifyMessage(envelope);    
        			     })
                  .catch(function(reason) {
                        //Konnte Nicht Entschlüsselt werden, als broadcast weiterleiten. 
                        self.notifyMessage({"topic":"broadcast","data":message.data});
                       });
            
        });
        
    };
    
    Network.sendMessage = function(topic,data) {
        //Nachrricht mit dem Aktuellen AES Key Verschlüsseln
        var self = this;
		var envelope = {
			'topic': topic,
			'data': data
		};
		this.cryptoManager.encryptString(JSON.stringify(envelope))
			.then(function(encryptedMessage) {
			self.ws.send(encryptedMessage);
		})
			.catch(function(params) {
			throw new Error("Konnte nicht Verschlüsseln");
		});
    };
    
    Network.sendDefaultEncryptedMessage = function(topic,data){
        //Benutzt immer den Allgemeinen AES-Key zum verschlüsseln.
		var self = this;
		var envelope = {
			'topic': topic,
			'data': data
		};
		this.cryptoDefault.encryptString(JSON.stringify(envelope))
			.then(function(encryptedMessage) {
			self.ws.send(encryptedMessage);
		})
			.catch(function(params) {
			throw new Error("Konnte nicht Verschlüsseln");
		});
    };
    
    Network.sendBroadcast = function(data) {
		//Sendet unverschlüsselt
		this.ws.send(data);
	};
    
    Network.createRoom = function(name) {
        var self = this;
         //Den Einen neuen EncryptionHandler für den Raum Erstellen
         self.cryptoManager = new EncryptionHandler(name);
         //  ROOM Objekt erstellen
            var room = document.createElement('x-room');
                room.setAttribute('room',name);
         self.appendChild(room);
                
    
        
    };
    
    
    
    
    Network.joinRoom = function(name) {
        var self = this;
        //Die Verschlüsselung wieder auf Default setzten
        this.cryptoManager = this.cryptoDefault; 
        
        if(self.firstChild){this.removeChild(this.firstChild);
        }
        
        if(name != undefined){
            new Promise(function(resolve,reject) {
                 //Aysnchron auf eine Antwort der Clienten Warten
                var listner = self.addEventListener(name,function(msg) {
                    window.clearTimeout(timeoutID);
                    if(msg.detail){
                        console.log("Confirm Erhalten -> IV :" + msg.detail);
                        //Aus der JSON wieder ein UINT8 Array erzeugen
                        var arr =[];
                        for(var i in msg.detail)
                        {
                            arr[i]=msg.detail[i];
                        }
                        var iv = new Uint8Array(arr);
                        self.removeEventListener(listner); // Wir mögen keine Speicherlecks
                        resolve(iv);
                    }
                    else{
                        console.log("Antwort ohne IV erhalten");
                        reject("Full");
                    }
                });
                
                
                //Nach 10 Sekunden das Verbinden beenden
                var timeoutID = window.setTimeout(function() {
                    self.removeEventListener(listner); //Verhindern das verspätet noch der IV Übernommen wird
                    console.log("Join Timeout");
                    reject("Timeout");
                }, 10000);
                
               
                
                self.sendDefaultEncryptedMessage('join',name);
                
            }).then(function(iv) {
                    //Erfolgreich einen IV bekommen.
                    //Den Einen neuen EncryptionHandler für den Raum Erstellen
                    self.cryptoManager = new EncryptionHandler(name,iv);
            
                    //Room Objekt erstellen
                        var room = document.createElement('x-room');
                        room.setAttribute('room',name);
                        self.appendChild(room);
                 
            });
        }
        //Wenn kein Name übergeben wurde einfach wieder in den Default room wechseln
        else{
            //Einen Promise der Sofort true gibt zurückgeben
            return new Promise(function(resolve) {
                resolve();
            });
        }
    };
    
    	
    Network.createdCallback = function() 
    {
        //Eigenschaften Prüfen, wenn gefunden übernehmen.
        var url     = this.getAttribute('url');
        this.setAttribute("connected","false");
        if(url != undefined){
            this.init(url);    
        }
      };
      
    Network.attributeChangedCallback = function(attribute, oldValue, newValue) {
      if(attribute=="url"){
          this.setAttribute("connected","false");
          this.init(newValue);
      }  
    };
        
        
       
       
     document.registerElement('x-network', {prototype: Network});
    }());
</script>
<!--  Flyout Component -Sebastian Streich

Bindet sich auf das Klick-Event des Parents und zeigt dann sein inneres HTML,
verschwindet wieder sobald ein anderes Element berührt wird.
-->




<template id="flyout-template">
  <div id='scaffholder'>
    <content></content>
  </div>
</template>
<script>
  (function() {
    	var flyout = Object.create(HTMLElement.prototype);


    	flyout.createdCallback = function() {
            this.tree       = this.createShadowRoot();
            var template    = document.querySelector('link[rel="import"]').import.querySelector('#flyout-template');
            var clone       = document.importNode(template.content, true);
            
            this.tree.appendChild(clone);
      };
      
      flyout.toggleVisibility = function() {
         if(this.getAttribute("class") != "hidden")
         {
           this.setAttribute('class','hidden');
         }
         else
         {
           this.setAttribute('class','');
         }
      };
      
      flyout.attachedCallback = function (params) {
            var self = this;
            try{
              //Versuchen sich an die EventHandler zu binden.
              var target = self.parentElement;
              target.addEventListener('click', 
                function(params) {
                  //An das Elternelement Binden um die Sichtbarkeit zu toggeln
                   if(target == event.target){
                    self.toggleVisibility(); 
                }});
                // Wenn im Fenster nicht auf das Eltern Element und nicht auf das Flyout geklickt wird, ausblenden
              window.addEventListener("click",function() {
                  if(self != event.target && self.parentElement != event.target){
                    self.setAttribute('class','hidden');
                  }
              });
            }
            catch(e){
               throw new Error("Couldnt Attach to parent");
            }
      };
       
    
        	
  
  
  	document.registerElement('x-Flyout', {prototype: flyout});
  }());
</script>