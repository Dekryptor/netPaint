<!-- Menu Component -Sebastian Streich

Erstellt eine Appbar an der Linken Seite die Buttons als Inhalt aufnimmt. 
Besitzt einen Button zum Verstecken des Menus wenn nicht gebraucht
-->

<template id="menu-template">
  	<div id="viewport">
          <div id='sidebar' class="">
            <div id='content-holder'>                
                    <content>
          
                    </content>
                    <hr></hr>  
            
              <button id='toggle-view'type="button" class='entypo-eye'></button> 
            </div>
          </div>
  	</div>
</template>


<script>
(function() {
  
  	var menu = Object.create(HTMLElement.prototype);
  	menu.createdCallback = function() {
          var tree      = this.createShadowRoot();
          var template  = document.querySelector('link[rel="import"]').import.querySelector('#menu-template');
          var clone = document.importNode(template.content, true);
          tree.appendChild(clone);
          
          //
          var visibilityswitch = tree.querySelector('#toggle-view');
          visibilityswitch.addEventListener
          ("click",function(e) {
             var sidebar = tree.querySelector('#sidebar');
             if(sidebar.getAttribute("class") != "hidden"){ sidebar.setAttribute ('class','hidden');}
             else {sidebar.setAttribute ('class','');}
          });
          
    };
      	


    document.registerElement('x-Menu', {prototype: menu});
}());
</script>


<!-- Network Component - Sebastian Streich 
Abstraktion des SocketManagers in eine HTML Component 



-->
<script>
    // Prototypen des EncryptionHandlers Definieren
    (function() {
    	var EncryptionHandler = (function () {
        function EncryptionHandler(keydata, initVektor) {
            var self = this;
            if (initVektor == undefined || initVektor.length == 0) {
                //Einen initierungsvektor erstellen, wenn keiner übergeben wurde.
                this.iv = window.crypto.getRandomValues(new Uint8Array(16));
            }
            else {
                this.iv = initVektor;
            }
            //Aus dem Raum-Namen einen 256bit Hash erstellen.
            this.sha256(keydata).then(function (digest) {
                //Aus dem Hash und den Vektor einen Cryptokey für AEC-CBC erstellen und Speichern.
                crypto.subtle.importKey("raw", digest, "AES-CBC", true, ["encrypt", "decrypt"]).then(function (keyObj) {
                    self.key = keyObj;
                });
            });
        }
        EncryptionHandler.prototype.sha256 = function (str) {
            // String in einen Arraybuffer umwandeln
            var buffer = new TextEncoder("utf-8").encode(str);
            return window.crypto.subtle.digest("SHA-256", buffer).then(function (hash) {
                return hash;
            });
        };
        EncryptionHandler.prototype.encryptString = function (data) {
            //Einen String mit dem AES-Key Verschlüsseln. 
            //Gibt einen Promise zurück - Welcher einen JSONifed String zurück gibt
            var self = this;
            var buffer = new TextEncoder('utf-8').encode(data);
            return new Promise(function (resolve, reject) {
                self.encryptBuffer(buffer).then(function (ergebnis) {
                    var bufferArray = new Uint8Array(ergebnis);
                    resolve(JSON.stringify(bufferArray));
                }).catch(function (reason) {
                    reject(reason);
                });
            });
        };
        EncryptionHandler.prototype.encryptBuffer = function (data) {
            //Einen Buffer mit dem AES-Key Verschlüsseln. 
            //Gibt einen Promise zurück mit einem Buffer als Argument
            var self = this;
            if (this.key == null) {
                throw new Error("Cryptokey ist nicht initialisiert.");
            }
            return new Promise(function (resolve, reject) {
                crypto.subtle.encrypt({ name: "AES-CBC", iv: self.iv }, self.key, data).then(function (encryptedBuffer) {
                    resolve(encryptedBuffer);
                }, function (params) {
                    reject(params);
                });
            });
        };
        EncryptionHandler.prototype.decryptJSON = function (data) {
            //Einen JSON-String mit dem AES-Key Entschlüsseln. 
            //Gibt einen Promise zurück - Welcher den UR - String zurück gibt
            var self = this;
            return new Promise(function (resolve, reject) {
                //Aus der JSON wieder einen Buffer erzeugen - Da der Server keine Binäre Übertragung unterstüzt.
                var obj = JSON.parse(data);
                var arr = [];
                for (var i in obj) {
                    arr[i] = obj[i];
                }
                var buffer = new Uint8Array(arr).buffer;
                //Buffer entschlüsseln
                self.decryptBuffer(buffer).then(function (decryptedBuffer) {
                    //Aus Buffer wieder einen String machen
                    resolve(new TextDecoder('utf-8').decode(decryptedBuffer));
                }).catch(function (reason) {
                    reject(reason);
                });
            });
        };
        EncryptionHandler.prototype.decryptBuffer = function (data) {
            //Einen Buffer entschlüsseln. 
            //Rückgabewert ist ein Promise mit Buffer als Argument.
            var self = this;
            return new Promise(function (resolve, reject) {
                crypto.subtle.decrypt({ name: "AES-CBC", iv: self.iv }, self.key, data).then(function (decryptedBuffer) {
                    resolve(decryptedBuffer);
                }).catch(function (reason) {
                    reject(reason);
                });
            });
        };
        EncryptionHandler.prototype.getInitVektor = function () {
            //Den IV Lesbar machen
            return this.iv;
        };
        return EncryptionHandler;
    })();
    	
    //Den Protoypen Erstellen und Erweitern
    var Network = Object.create(HTMLElement.prototype);
    
    Network.notifyMessage = function(envelope) {
        //Ein Event schicken, an alle Elemente die sich an den Typ der Message gebunden haben.
        var event = new CustomEvent(envelope.topic, { 'detail': envelope.data });
        this.dispatchEvent(event);
    };
    
    Network.init = function(url) {
       var self    = this;
       this.ws = new WebSocket(url);
            this.ws.onopen = function(params) {
    			console.log("Verbindung Geöffnet.");
    			//Generellen CryptoManager laden.
    			self.cryptoManager = self.cryptoDefault;
    		};
       
       //Eventlistner für das Empfangen erstellen
       this.ws.addEventListener('message', function(message) {
    			//Nachricht enschlüsseln
    			self.cryptoManager.decryptJSON(message.data)
    		      .then(function(params) {
        				var envelope = JSON.parse(params);
        				self.notifyMessage(envelope);    
        			     })
                  .catch(function(reason) {
                        //Konnte Nicht Entschlüsselt werden.
                        self.notifyMessage({"topic":"broadcast","data":message.data});
                       });
            
        });
        
    };
    
    Network.sendMessage = function(topic,data) {
        //Nachrricht mit dem Aktuellen AES Key Verschlüsseln
        var self = this;
		var envelope = {
			'topic': topic,
			'data': data
		};
		this.cryptoManager.encryptString(JSON.stringify(envelope))
			.then(function(encryptedMessage) {
			self.ws.send(encryptedMessage);
		})
			.catch(function(params) {
			throw new Error("Konnte nicht Verschlüsseln");
		});
    };
    
    Network.sendDefaultEncryptedMessage = function(topic,data){
        //Benutzt immer den Allgemeinen AES-Key zum verschlüsseln.
		var self = this;
		var envelope = {
			'topic': topic,
			'data': data
		};
		this.cryptoDefault.encryptString(JSON.stringify(envelope))
			.then(function(encryptedMessage) {
			self.ws.send(encryptedMessage);
		})
			.catch(function(params) {
			throw new Error("Konnte nicht Verschlüsseln");
		});
    };
    
    Network.sendBroadcast = function(data) {
		//Sendet unverschlüsselt
		this.ws.send(data);
	};
    	
    Network.createdCallback = function() 
    {
        //Eigenschaften Prüfen, wenn gefunden übernehmen.
        var url     = this.getAttribute('url');
        var room    = this.getAttribute('room');
        var self    = this;
        //Standard CryptoObjekt Erstellen
        var defaultvek      = new Uint8Array([38, 86, 215, 184, 230, 210, 185, 187, 139, 141, 157, 192, 67, 41, 251, 58]);
        this.cryptoDefault  = new EncryptionHandler("none",defaultvek);
        
        if(url != undefined){
            this.init(url);    
        }
      };
        
        
       
       
     document.registerElement('x-network', {prototype: Network});
    }());
</script>
<!--  Flyout Component -Sebastian Streich

Bindet sich auf das Klick-Event des Parents und zeigt dann sein inneres HTML,
verschwindet wieder sobald ein anderes Element berührt wird.
-->




<template id="flyout-template">
  <div id='scaffholder'>
    <content></content>
  </div>
</template>
<script>
  (function() {
    	var flyout = Object.create(HTMLElement.prototype);


    	flyout.createdCallback = function() {
            this.tree       = this.createShadowRoot();
            var template    = document.querySelector('link[rel="import"]').import.querySelector('#flyout-template');
            var clone       = document.importNode(template.content, true);
            
            this.tree.appendChild(clone);
      };
      
      flyout.toggleVisibility = function() {
         if(this.getAttribute("class") != "hidden")
         {
           this.setAttribute('class','hidden');
         }
         else
         {
           this.setAttribute('class','');
         }
      };
      
      flyout.attachedCallback = function (params) {
            var self = this;
            try{
              //Versuchen sich an die EventHandler zu binden.
              var target = self.parentElement;
              target.addEventListener('click', 
                function(params) {
                  //An das Elternelement Binden um die Sichtbarkeit zu toggeln
                   if(target == event.target){
                    self.toggleVisibility(); 
                }});
                // Wenn im Fenster nicht auf das Eltern Element und nicht auf das Flyout geklickt wird, ausblenden
              window.addEventListener("click",function() {
                  if(self != event.target && self.parentElement != event.target){
                    self.setAttribute('class','hidden');
                  }
              });
            }
            catch(e){
               throw new Error("Couldnt Attach to parent");
            }
      };
       
    
        	
  
  
  	document.registerElement('x-Flyout', {prototype: flyout});
  }());
</script>